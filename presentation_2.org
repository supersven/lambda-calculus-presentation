#+TITLE: Simply Typed Lambda Calculus
#+AUTHOR: Sven Tennie
#+EMAIL: sven.tennie@dreamit.de
#+KEYWORDS: "Simply Typed Lambda Calculus"
#+LANGUAGE:  en
#+OPTIONS: tasks:nil toc:nil H:2
#+BEAMER_THEME: metropolis
#+BEAMER_HEADER: \subtitle{From Untyped to Simply Typed Lambda Calculus}
#+BEAMER_HEADER: \institute[INST]{Dream IT\\\url{https://dreamit.de}}
#+startup: beamer
#+LaTeX_CLASS: beamer
#+LaTeX_HEADER: \usemintedstyle{tango}
#+LaTeX_HEADER: \usepackage{fontspec}
# #+LaTeX_HEADER: \setmonofont[Contextuals={Alternate}]{Fira Code}
#+LaTeX_HEADER: \newminted{haskell}{fontsize=\tiny,mathescape=true}
#+LaTeX_HEADER: \setminted[haskell]{fontsize=\tiny,mathescape=true}

* Untyped Lambda Calculus
** Untyped Lambda Calculus - Recapitulation
*** We can boil down computation to a tiny calculus
#+BEAMER: \pause
*** All we need is:
- Function Definition / *Abstraction* ($\lambda x . e$)
- Function *Application* ($e \ e$)
- Parameters / *Variables* ($x$)
#+BEAMER: \pause
*** Then we get:
**** PL constructs :B_column:
     :PROPERTIES:
     :BEAMER_col: 0.35
     :BEAMER_env: block
     :BEAMER_envargs: C[t]
     :END:
- Booleans
- Numerals
- Data Structures
- Control Flow
- ...
#+BEAMER: \pause
**** Turing Completeness :B_column:
     :PROPERTIES:
     :BEAMER_col: 0.55
     :BEAMER_env: block
     :BEAMER_envargs: C[t]
     :END:
- *Turing Completeness* 
  - If it can be computed, it can be computed in Lambda Calculus!

** Build an Interpreter
*** Let's build an interpreter
- Deepen our intiution
- Later move on to the /Simply Typed Lambda Calculus/
  - Why do we need types?
  - How does a type checker work?
  - How does it restrict the programs we might write?

- On our way we'll learn some math mumbo-jumbo: /Natural Deduction/
  - Found in many papers about Type Systems and Programming Language Evaluation

** Structure
\begin{align*}
e ::= & & \text{Expressions:} \\
& \ x & \text{Variable} \\
& \ \lambda x.e & \text{Abstraction} \\
& \ e \ e & \text{Application}
\end{align*}

** Abstract Syntax Tree
$(\lambda x . \lambda y . x \ y) \ a \ b$
#+BEGIN_SRC dot :file dot/untyped_lambda_calculus_ast.dot.ps :tangle dot/untyped_lambda_calculus_ast.dot
digraph untyped_lambda_calculus_ast {
  A [label = "Application"];
  B [label = "Application"];
  C [label = "Lambda"];
  D [label = "Lambda"];
  E [label = "Application"];
  F [label = "Variable a"];
  G [label = "Variable b"];
  H [label = "Parameter x"];
  I [label = "Parameter y"];
  J [label = "Variable x"];
  K [label = "Variable y"];
  
  A -> {B G}
  B -> {C F}
  C -> {H D}
  D -> {I E}
  E -> {J K}
}
#+END_SRC

#+attr_latex: :height 5cm
#+RESULTS:
[[file:dot/untyped_lambda_calculus_ast.dot.ps]]

** Interpreter - Syntax
#+BEGIN_SRC haskell :tangle src/UntypedSyntax.hs
  module UntypedSyntax where

  type Name = String

  data Expr
    = Var Name
    | App Expr
          Expr
    | Lambda Name
             Expr
    deriving (Eq, Show)
#+END_SRC

** Interpreter - Syntax - Examples

#+BEGIN_SRC haskell :tangle src/UntypedSyntaxExamples.hs
  module UntypedSyntaxExamples where

  import UntypedSyntax

  -- $true \equiv \lambda p . \ lambda q . p$
  true :: Expr
  true = Lambda "p" (Lambda "q" (Var "p"))

  -- $false \equiv \lambda p . \ lambda q . q$
  false :: Expr
  false = Lambda "p" (Lambda "q" (Var "p"))

  -- $if\_then\_else \equiv \lambda p . \lambda a . \lambda b . p a b $
  if_then_else :: Expr
  if_then_else =
    Lambda "p" (Lambda "a" (Lambda "b" (App (App (Var "p") (Var "a")) (Var "b"))))
#+END_SRC

** Evaluation Rules - Call by Value
Some rules...

\begin{align*}
 \frac{e_1 \to e_1'}{e_1 e_2 \to e_1' e_2} & \quad & \text{E-App1} \\ \\
 \frac{e_2 \to e_2'}{v_1 e_2 \to v_1 e_2'} & \quad & \text{E-App2} \\ \\
 {(\lambda x . e) v \to [x / v] e } & \quad & \text{E-AppLam} \\ \\
\end{align*}


** Interpreter - Evaluation
#+BEGIN_SRC haskell :tangle src/NaiveUntypedEval.hs

  module NaiveUntypedEval where

  import UntypedSyntax

  eval :: Expr -> Expr
  -- No rule for variables
  eval variable@(Var _) = variable
  -- No rule for lambdas
  eval lambda@(Lambda _ _) = lambda
  eval (App e1 e2)
  -- $ \frac{e_1 \to e_1'}{e_1 e_2 \to e_1' e_2} \quad (E-App1) $
   =
    let e1' = eval e1
  -- $ \frac{e_2 \to e_2'}{v_1 e_2 \to v_1 e_2'} \quad (E-App2) $
     in let e2' = eval e2
         in case e1'
                  of
  -- $ {(\lambda x . e) v \to [x / v] e } \quad (E-AppLam) $
              (Lambda name e1'_body) -> eval $ substitute name e2' e1'_body
              e1' -> App e1' e2'
#+END_SRC

** Interpreter - Substitution
#+BEGIN_SRC haskell :tangle src/NaiveUntypedEval.hs
  substitute :: String -> Expr -> Expr -> Expr
  substitute name substitution var@(Var varName)
    | name  == varName = substitution
    | otherwise = var
  substitute name substitution (App term1 term2) =
    App (substitute name substitution term1) (substitute name substitution term2)
  substitute name substitution (Lambda varName term) =
    if name == varName
      then Lambda varName term
      else Lambda varName (substitute name substitution term)
#+END_SRC

** Interpreter with Environment
#+BEGIN_SRC haskell :tangle src/UntypedEval.hs
  module UntypedEval where

  import UntypedSyntax

  import qualified Data.Map.Strict as Map

  type Environment = Map.Map Name Expr

  eval :: Environment -> Expr -> Maybe Expr
  eval env (Var name) = find env name
  eval env (App term1 term2) = case eval env term1 of
    Just (Lambda name term) -> eval (Map.insert name term2 env) term
    Just term                    -> Just (App term term2)
    Nothing -> Nothing
  eval env lambda@(Lambda _ _) = Just lambda

  find ::  Environment -> Name -> Maybe Expr
  find env name = Map.lookup name env
#+END_SRC

** Tests
* Simply Typed Lambda Calculus
** Structure
\begin{align*}
e ::= & & \text{Expressions:} \\
& \ x & \text{Variable} \\
& \ \lambda x:\tau.e & \text{Abstraction} \\
& \ e \ e & \text{Application}
\end{align*}
** Progress and Preservation
*** **Progress** :  If an expression is well typed then either it is a value, or it can be further evaluated by an available evaluation rule.
*** **Preservation** : If an expression $e$ has type $\tau$, and is evaluated to $e'$, then $e'$ has type $\tau$.

** Evaluation
*** Dynamic rules stay the same!
    - Type checking is done upfront

** Interpreter


** Typing Rules
\begin{align*}
 \frac{x:\sigma \in \Gamma}{\Gamma \vdash x:\sigma} & \quad & \text{T-Var} \\ \\
 \frac{\Gamma, x : \tau_1 \vdash e : \tau_2}{\Gamma \vdash \lambda x:\tau_1 . e : \tau_1 \rightarrow \tau_2 } & \quad & \text{T-Lam} \\ \\
 \frac{\Gamma \vdash e_1 : \tau_1 \rightarrow \tau_2 \quad \Gamma \vdash e_2 : \tau_1}{\Gamma \vdash e_1 e_2 : \tau_2} & \quad & \text{T-App} \\ \\
 \Gamma \vdash n : \text{Int} & \quad & \text{T-Int} \\ \\
 \Gamma \vdash \text{True} : \text{Bool} & \quad & \text{T-True} \\ \\
 \Gamma \vdash \text{False} : \text{Bool} & \quad  & \text{T-False} \\ \\
\end{align*}  

** Type Checker
#+BEGIN_SRC haskell :tangle src/TypedSyntax.hs
  module TypedSyntax where

  import qualified Data.Map.Strict as Map

  type Name = String

  type Environment = Map.Map Name Type

  data Type
    = TInt
    | TBool
    | TArr Type
           Type
    deriving (Eq, Show)

  data Expr
    = IntValue Int
    | BoolValue Bool
    | Var Name
    | App Expr
          Expr
    | Lambda Name
             Type
             Expr
    deriving (Eq, Show)

#+END_SRC

** Type Checker - Literals & Variables
#+BEGIN_SRC haskell :tangle src/TypedCheck.hs
  module TypedCheck where

  import Data.Either.Extra
  import qualified Data.Map.Strict as Map

  import TypedSyntax

  find :: Environment -> Name -> Either String Type
  find env name = maybeToEither "Var not found!" (Map.lookup name env)

  check :: Environment -> Expr -> Either String Type
  --
  -- $ \Gamma \vdash n : \text{Int}  \quad  \text{(T-Int)} $
  --
  check _ (IntValue _) = Right TInt
  --
  -- $ \Gamma \vdash \text{True} : \text{Bool}  \quad  \text{(T-True)} $
  --
  check _ (BoolValue True) = Right TBool
  --
  -- $ \Gamma \vdash \text{False} : \text{Bool}  \quad   \text{(T-False)} $
  --
  check _ (BoolValue False) = Right TBool
  --
  -- $  \frac{x:\sigma \in \Gamma}{\Gamma \vdash x:\sigma}  \quad  \text{(T-Var)} $
  --
  check env (Var name) = find env name
#+END_SRC

** Type Checker - Lambda & Application
#+BEGIN_SRC haskell :tangle src/TypedCheck.hs
--
-- $ \frac{\Gamma, x : \tau_1 \vdash e : \tau_2}{\Gamma \vdash \lambda x:\tau_1 . e : \tau_1 \rightarrow \tau_2 }  \quad  \text{(T-Lam)} $
--
check env (Lambda name atype e) = do
  t <- check (Map.insert name atype env) e
  return $ TArr atype t
--
-- $  \frac{\Gamma \vdash e_1 : \tau_1 \rightarrow \tau_2 \quad \Gamma \vdash e_2 : \tau_1}{\Gamma \vdash e_1 e_2 : \tau_2}  \quad  \text{(T-App)} $
--
check env (App e1 e2) = do
  (TArr ta1 ta2) <- check env e1
  t2 <- check env e2
  if ta1 == t2
    then Right ta2
    else Left $ "Expected " ++ (show ta1) ++ " but got : " ++ (show t2)
#+END_SRC

