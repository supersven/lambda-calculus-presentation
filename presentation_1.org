#+TITLE: Untyped Lambda Calculus
#+AUTHOR: Sven Tennie
#+EMAIL: sven.tennie@dreamit.de
#+KEYWORDS: "Simply Typed Lambda Calculus" "Church Encoding" "Currying"
#+LANGUAGE:  en
#+OPTIONS: tasks:nil toc:nil
#+BEAMER_THEME: metropolis

#+startup: beamer
#+LaTeX_CLASS: beamer

* Lambda Calculus
- Invented by Alonzo Church (1920s)
- Equally expressive to the Turing Machine(s)
- Formal Language
- Computational Model
  - Lisp (1950s)
  - ML
  - Haskell
- "Lambda Expressions" in almost every modern programming language
 
* Why should I care?
- Simple Computational Model
  - to describe structure and behaviour (E.g. Operational Semantics)
  - to reason and proove
#+BEAMER: \pause
- Explains why things in FP are like they are
  - pure functions
  - higher-order functions
  - currying
  - lazy evaluation
#+BEAMER: \pause
- Understand FP Compilers
  - Introduce FP stuff into other languages
  - Write your own compiler
  - GHC uses an enriched Lambda Calculus internally

* Untyped Lambda Calculus

\begin{align*}
t ::=& \ x & \text{Variable} \\
& \ \lambda x.t & \text{Abstraction} \\
& \ t \ t & \text{Application}
\end{align*}

#+BEAMER: \pause

** Example
- Identity


*** Lambda Calculus                                                :B_block:BMCOL:
    :PROPERTIES:
    :BEAMER_col: 0.45
    :BEAMER_env: block
    :END:
    \begin{equation*}
    \underbrace{
      \underbrace{\lambda x.x}_\text{Abstraction}
      \quad
      \underbrace{y}_\text{Variable}
    }_\text{Application}
    \to y
    \end{equation*}
#+BEAMER: \pause
*** Javascript                                                :B_block:BMCOL:
    :PROPERTIES:
    :BEAMER_col: 0.45
    :BEAMER_env: block
    :END:
\begin{equation*}
\underbrace{(\underbrace{function \ (x)\{return \ x;\}}_{Abstraction}) \ (\underbrace{y}_{Variable})}_{Application}
\end{equation*}

* Evaluation / Reduction
\begin{equation*}
\underbrace{\underbrace{(\underbrace{\lambda x . \underbrace{\lambda y . \underbrace{x \ y}_{Application}}_{Abstraction}}_{Abstraction}) \underbrace{a}_{Variable}}_{Application} \  \underbrace{b}_{Variable}}_{Application}
\end{equation*}
#+BEAMER: \pause
\begin{align*}
& (\lambda \colorbox{orange!50}{x} . \lambda y . \colorbox{orange!50}{x} \ y) \colorbox{orange!50}{a} b \\
\onslide<3->{\to & (\lambda \colorbox{cyan!50}{y} . a \ \colorbox{cyan!50}{y}) \colorbox{cyan!50}{b} \\}
\onslide<4->{\to & a \ b}
\end{align*}

\onslide<5->{Parentheses are not part of the grammer? See next slide :) }

* Notational Conventions
- We use parentheses to clearify what's meant
- Applications associate to the left
\begin{equation*}
s \ t \ u \equiv (s \ t) \ u
\end{equation*}
- Lambda Expressions expand as much to the right as possible
\begin{equation*}
\lambda x . \lambda y . x \ y \ x \equiv \lambda x . ( \lambda y . ((x \ y) \ x))
\end{equation*}

* Scope
\begin{equation*}
\lambda x . \lambda y . x \ y \ z
\end{equation*}

- $\lambda y$ :: $y$ is /bound/, $x$ and $z$ are /free/
- $\lambda x$ :: $x$ and $y$ are /bound/, $z$ is free
- $\lambda x$, $\lambda y$ :: /binder/

- A term with no free variables is /"closed"/
  - A /"combinator"/
  - $id \equiv \lambda x . x$

* Operational Semantics
- We learned how to write down and talk about Lambda Calculus Terms

- How to evaluate them?

- Different Strategies
  - Interesting outcomes

* Full Beta-Reduction
- RedEx
  - \textbf{Red}ucible \textbf{Ex}pression
  - Always an Application

\begin{equation*}
\underbrace{
(\lambda x.x) \ (\underbrace{(\lambda x.x) \ (\lambda z.\underbrace{(\lambda x.x) \ z}_{RedEx})}_{RedEx})
}_{RedEx}
\end{equation*}
#+BEAMER: \pause
- Full Beta-Reduction 
  - Any RedEx,  Any Time
  - Like in Arithmetics
  - Too fuzzy to program...
    - How to write a good test if the next step could be several expressions?

* Normal Order Reduction
\begin{align*}
\alt<1>{ & (\lambda x.x) \ ((\lambda x.x) \ (\lambda z.(\lambda x.x) \ z)) \\ } { & \underline{ (\lambda x.x) \ ((\lambda x.x) \ (\lambda z.(\lambda x.x) \ z)) } \\ }
\onslide<3->{\alt<3>{\to & (\lambda x.x) \ (\lambda z.(\lambda x.x) \ z) \\ } {\to & \underline{(\lambda x.x) \ (\lambda z.(\lambda x.x) \ z) } \\ }}
\onslide<5->{\alt<5>{\to & (\lambda z.(\lambda x.x) \ z)}{\to & \underline{(\lambda z.(\lambda x.x) \ z)}} \\ }
\onslide<5->{\to & (\lambda z.z) }
\end{align*}

- Normal Order Reduction
  - Left-most, Outer-most RedEx

* Call-by-Name
- Call-by-Name
  - lazy, non-strict
  - Parameters are NOT evaluated before they are passed to Lambdas
  - Lambdas are values
  - Save result -> Call-by-Need
  - No reduction inside Abstractions

* Call-by-Value
- Call-by-Value
  - eager, strict


* Higher Order Functions
- Functions that take or return functions
  - Are there "by definition"

\begin{equation*}
\underbrace{
  \underbrace{\lambda x.x}_{Abstraction}
 \quad
 \underbrace{\lambda y.y}_{Abstraction}
}_{Application}
\to \underbrace{\lambda y.y}_{Abstraction}
\end{equation*}

* Currying
$(\lambda x . \lambda y . x y) z  \to \lambda y . z y$

- Example
  - ~(+1)~ Section in Haskell
$(\lambda x . \lambda y . + x y) 1  \to \lambda y . + 1 y$

- Partial Application is there "by definition"

* Remarks
- Everything (Term) is an Expression
  - No statements
- No "destructive" Variable Assignments
  - The reason why FP Languages promote pure functions

* Reductions and Conversions
- Alpha conversion
$\lambda x . x \to_\alpha \lambda y . y$

#+BEAMER: \pause

- Beta reduction
$(\lambda x . x) y \to_\beta y$

#+BEAMER: \pause

- Eta conversion
  - iff (if and only if) x is not free in f 
$(\lambda x . f \ x) \to_\eta f$

$(\lambda x . (\lambda y . y) \ x) \to_\eta \lambda y . y$

  - x is not free in f
$(\lambda x . (\lambda y . x) \ x)$

* Translate Lambda Calculus to Javascript
Variable -> Variable
Abstraction -> Function Declaration
Application -> Function Call

* Church Encodings

- Encode Data into the Lambda Calculus

- To simplify our formulas, let's say that we have declarations

\begin{equation*}
id \equiv \lambda x.x \\
id y \to y
\end{equation*}

* Booleans
\begin{align*}
true \equiv \lambda t. \lambda f.t \\
false \equiv \lambda t. \lambda f.f \\
\\
if\_then\_else \equiv 
 \lambda c . 
 \lambda b_{true} . 
 \lambda b_{false} . 
 c \ b_{true} \ b_{false}
\end{align*}

** Example
\begin{align*}
& if\_then\_else \ true \ a \ b \\
\equiv & \ (\lambda c . \lambda b_{true} .  \lambda b_{false} .  c \ b_{true} \ b_{false}) \ true \ a \ b \\
\to & true \ a \ b \\
\equiv & (\lambda t. \lambda f.t) \ a \ b \\
\to & (\lambda f.a) \ b \\
\to & a
\end{align*}

* And
\begin{align*}
true \equiv \lambda t. \lambda f.t \\
false \equiv \lambda t. \lambda f.f \\
\\
and \equiv \lambda p . \lambda q . p \ q \ p
\end{align*}

- Example
\begin{align*}
& and \ true \ false \\
\equiv & (\lambda p . \lambda q . p \ q \ p) \ true \ false \\
\to & (\lambda q . true \ q \ true) \ false \\
\to & true false true \\
\equiv & (\lambda t. \lambda f.t) \ false \ true \\
\to & (\lambda f .false) true \\
\to & false
\end{align*}

* Or
$\lambda p . \lambda q . p p q$

* Pairs
\begin{align*}
pair \equiv \lambda x. \lambda y . \lambda z . z\ x\ y \\
first \equiv (\lambda p. p) (\lambda x . \lambda y . x) \\
second \equiv (\lambda p. p) (\lambda x . \lambda y . y)
\end{align*}

** Example
\begin{align*} 
pair_{AB} & \equiv pair & \ a \ b \\
& \equiv & (\lambda x. \lambda y . \lambda z . z\ x\ y) \ a \ b \\
& \to & (\lambda y . \lambda z . z\  a\ y) b \\
& \to & \lambda z . z\  a \ b \\
& \equiv & pair'_{ab} \\
\end{align*}

* Pair Example (continued)
\begin{align*}
pair'_{ab} & \equiv & \lambda z . z\  a \ b \\
first & \equiv & (\lambda p. p) (\lambda x . \lambda y . x) \\
\\
first \ pair'_{ab} & \equiv & (\lambda p. p) (\lambda x . \lambda y . x) pair'_{ab} \\
& \to & pair'_{ab} (\lambda x . \lambda y . x) \\
& \equiv & (\lambda z . z\  a \ b) (\lambda x . \lambda y . x) \\
& \to & (\lambda x . \lambda y . x) \ a \ b \\
& \to & (\lambda y . a) \ b \\
& \to & a
\end{align*}
# TODO Is pair_{ab} equivalent to it's reduced result?
* Numerals

- Peano axioms
  - Every natural number can be defined with $0$ and a successor function
\begin{align*}
0 & \equiv & \lambda f. \lambda x. x \\
1 & \equiv & \lambda f. \lambda x. f \ x \\
2 & \equiv & \lambda f. \lambda x. f \ (f \ x) \\
3 & \equiv & \lambda f. \lambda x. f \ (f \ (f \ x)) \\
\end{align*}
- Meaning
  - $0$ :: $f$ is evaluated $0$ times
  - $1$ :: $f$ is evaluated once
  - $x$ :: can be every lambda term

* Numerals Example - Successor

\begin{align*}
0 & \equiv & \lambda f. \lambda x. x \\
1 & \equiv & \lambda f. \lambdax. f \ x \\
\\
successor & \equiv & \lambda n.  \lambda f. \lambda x. f \ (n \ f \ x) \\
\\
successor 1 & \equiv & (\lambda n.  \lambda f. \lambda x. f \ (n \ f \ x)) 1 \\
& \to & \lambda f. \lambda x. f \ (1 \ f \ x) \\
& \equiv \lambda f. \lambda x. f \ ((\lambda f. \lambda x. f \ x) \ f \ x) \\
& to & \lambda f. \lambda x. f \ ((\lambda x. f \ x) \ x) \\
& to & \lambda f. \lambda x. f \ (f \ x) \\
& \equiv & 2
\end{align*}

* Numerals Example - 0 + 0

\begin{align*}
0 & \equiv & \lambda f. \lambda x. x 
\\
plus & \equiv & \lambda m. \lambda n. \lambda f. \lambda x. m f (n f x) \\
\\
plus \ 0 \ 0 & \equiv & (\lambda m. \lambda n. \lambda f. \lambda x. m f (n f x)) \ 0 \ 0 \\
& \to & (\lambda n. \lambda f. \lambda x. 0 f (n f x)) \ 0 \\
& \to & (\lambda f. \lambda x. 0 f (0 f x)) \\
& \equiv & (\lambda f. \lambda x. (\lambda f. \lambda x. x) f (0 f x)) \\
& \to & (\lambda f. \lambda x. (\lambda x. x) (0 f x)) \\
& \to & (\lambda f. \lambda x. (0 f x)) \\
& \equiv & (\lambda f. \lambda x. ((\lambda f. \lambda x. x) f x)) \\
& \to & (\lambda f. \lambda x. ((\lambda x. x) x)) \\
& \to & (\lambda f. \lambda x. x \\
& \equiv & 0
\end{align*}

* Books
The implementation of programming languages
Type Systems

* Thanks
- Hope you enjoyed this talk and learned something new.
- Hope it wasn't too much math and dusty formulas ... :)
